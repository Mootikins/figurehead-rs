//! Visual output testing with VHS tape generation
//!
//! These tests generate VHS tape files for terminal screenshot capture.
//! Run with VHS installed: `vhs target/visual-tests/*.tape`
//!
//! Install VHS: https://github.com/charmbracelet/vhs
//! - go install github.com/charmbracelet/vhs@latest
//! - Or: brew install vhs

use std::path::PathBuf;

/// Get the workspace root directory
fn workspace_root() -> PathBuf {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
        .map(PathBuf::from)
        .unwrap_or_else(|_| std::env::current_dir().unwrap());
    manifest_dir.parent().unwrap().parent().unwrap().to_path_buf()
}

/// Directory for visual test outputs
fn visual_output_dir() -> PathBuf {
    let dir = workspace_root().join("target/visual-tests");
    std::fs::create_dir_all(&dir).ok();
    dir
}

/// Generate a VHS tape file for a given diagram
fn generate_tape(name: &str, input: &str, style: &str) -> PathBuf {
    let input_dir = visual_output_dir().join("inputs");
    std::fs::create_dir_all(&input_dir).ok();

    // Write input file
    let input_path = input_dir.join(format!("{}.mmd", name));
    std::fs::write(&input_path, input).expect("Failed to write input");

    // Generate tape file
    let tape_path = visual_output_dir().join(format!("{}.tape", name));
    let output_path = visual_output_dir().join(format!("{}.png", name));

    let tape_content = format!(
        r#"# VHS tape for {name}
# Generated by figurehead visual tests

Output "{output}"

Set Shell "bash"
Set FontSize 14
Set Width 1200
Set Height 800
Set Theme "Dracula"

Type "FIGUREHEAD_LOG_LEVEL=off ./target/debug/figurehead convert -i {input} --style {style}"
Enter
Sleep 500ms
Screenshot "{output}"
"#,
        name = name,
        output = output_path.display(),
        input = input_path.display(),
        style = style,
    );

    std::fs::write(&tape_path, &tape_content).expect("Failed to write tape");
    tape_path
}

/// Generate a VHS runner script
fn generate_runner_script() {
    let script_path = visual_output_dir().join("run_vhs.sh");
    let script = r#"#!/bin/bash
# Run all VHS tapes to generate screenshots
# Requires: vhs (go install github.com/charmbracelet/vhs@latest)

set -e

if ! command -v vhs &> /dev/null; then
    echo "VHS not found. Install with: go install github.com/charmbracelet/vhs@latest"
    exit 1
fi

cd "$(dirname "$0")/../.."

# Build first
cargo build -p figurehead-cli

# Run each tape
for tape in target/visual-tests/*.tape; do
    echo "Running: $tape"
    vhs "$tape"
done

echo "Screenshots generated in target/visual-tests/"
"#;

    std::fs::write(&script_path, script).expect("Failed to write runner script");

    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(&script_path, std::fs::Permissions::from_mode(0o755)).ok();
    }
}

#[test]
fn test_generate_simple_chain_lr_tape() {
    let input = r#"flowchart LR
    A --> B --> C"#;
    let tape = generate_tape("simple_chain_lr", input, "unicode");
    assert!(tape.exists());
    println!("Generated: {}", tape.display());
}

#[test]
fn test_generate_simple_chain_td_tape() {
    let input = r#"flowchart TD
    A --> B --> C"#;
    let tape = generate_tape("simple_chain_td", input, "unicode");
    assert!(tape.exists());
    println!("Generated: {}", tape.display());
}

#[test]
fn test_generate_diamond_decision_tape() {
    let input = r#"flowchart TD
    A --> B{Decision}
    B -->|Yes| C
    B -->|No| D"#;
    let tape = generate_tape("diamond_decision", input, "unicode");
    assert!(tape.exists());
    println!("Generated: {}", tape.display());
}

#[test]
fn test_generate_all_shapes_tape() {
    let input = r#"flowchart LR
    A[Rectangle] --> B(Rounded)
    B --> C{Diamond}
    C --> D([Stadium])
    D --> E[[Subroutine]]
    E --> F[(Database)]
    F --> G((Circle))
    G --> H>Asymmetric]"#;
    let tape = generate_tape("all_shapes", input, "unicode");
    assert!(tape.exists());
    println!("Generated: {}", tape.display());
}

#[test]
fn test_generate_style_comparison_tapes() {
    let input = r#"flowchart LR
    A --> B --> C"#;

    for style in ["ascii", "unicode", "compact", "unicode-math"] {
        let tape = generate_tape(&format!("style_{}", style), input, style);
        assert!(tape.exists());
        println!("Generated: {}", tape.display());
    }
}

#[test]
fn test_generate_runner_script() {
    generate_runner_script();
    let script = visual_output_dir().join("run_vhs.sh");
    assert!(script.exists());
    println!("Generated runner: {}", script.display());
}

/// Generate manifest for VL model verification
#[test]
fn test_generate_manifest() {
    let manifest_path = visual_output_dir().join("manifest.json");

    let tests = vec![
        ("simple_chain_lr.png", "Horizontal chain A->B->C, boxes should align horizontally on same row"),
        ("simple_chain_td.png", "Vertical chain A->B->C, boxes should stack vertically in a column"),
        ("diamond_decision.png", "Decision diamond with Yes/No branches, diamond should be symmetric"),
        ("all_shapes.png", "Gallery of all node shapes in horizontal layout"),
        ("style_ascii.png", "ASCII style using +/-/| characters"),
        ("style_unicode.png", "Unicode style with box-drawing characters"),
        ("style_compact.png", "Compact style with minimal spacing"),
        ("style_unicode-math.png", "Unicode-math style with mathematical symbols"),
    ];

    let manifest: serde_json::Value = serde_json::json!({
        "description": "Visual test outputs for figurehead ASCII diagram renderer",
        "generation": "Run: ./target/visual-tests/run_vhs.sh",
        "verification_prompts": {
            "alignment": "Check that box corners are vertically aligned. In LR layouts, all boxes should have their top edges on the same row.",
            "symmetry": "Diamond shapes should have equal-length diagonal lines on both sides.",
            "spacing": "Spacing between elements should be consistent throughout the diagram.",
            "labels": "All text labels should be fully contained within their node shapes.",
            "connections": "Edges should connect cleanly to node borders without gaps or overlaps."
        },
        "tests": tests.iter().map(|(file, desc)| {
            serde_json::json!({
                "file": file,
                "description": desc
            })
        }).collect::<Vec<_>>()
    });

    std::fs::write(&manifest_path, serde_json::to_string_pretty(&manifest).unwrap())
        .expect("Should write manifest");

    println!("Generated manifest: {}", manifest_path.display());
}
